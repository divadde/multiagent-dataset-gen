import traceback
import pandas as pd
from typing import List, Dict, Optional
from workflow.graph_orchestrator import build_parallel_graph

def generate_synthetic_dataset(
        num_rows: int,
        rules: List[Dict],
        output_path: str = "synthetic_dataset.csv",
        script_output_path: Optional[str] = None,
        max_retries: int = 4
) -> Optional[pd.DataFrame]:
    """
    Funzione Proxy che orchestra la generazione parallela del dataset.

    1. Inizializza lo stato con le regole grezze.
    2. Invoca il grafo (Master -> Workers -> Merger).
    3. Riceve il codice Python completo.
    4. Esegue il codice localmente per ottenere il DataFrame finale.
    """

    # 1. Configurazione Path Script
    if script_output_path is None:
        base_name = output_path.rsplit('.', 1)[0]
        script_output_path = f"{base_name}_gen.py"

    print(f"üöÄ Starting Parallel Dataset Generation ({num_rows} rows)...")
    print(f"‚ÑπÔ∏è  Input: {len(rules)} rules provided.")

    # 2. Inizializzazione Stato del Grafo
    # NOTA: Non creiamo pi√π il prompt testuale qui. Passiamo i dati grezzi.
    # Il Master Agent si occuper√† di analizzare le 'original_rules'.
    initial_state = {
        "user_instructions": "Generate a synthetic dataset respecting the provided constraints.",
        "original_rules": rules,
        "num_rows": num_rows,
        # Importante: inizializzare le liste vuote per il reducer del grafo
        "generated_code_snippets": [],
        "final_combined_code": ""
    }

    # 3. Invocazione del Grafo Multi-Agente
    try:
        # Compila ed esegue il grafo
        app = build_parallel_graph()
        final_state = app.invoke(initial_state)
    except Exception as e:
        print(f"‚ùå Critical error during graph execution: {e}")
        traceback.print_exc()
        return None

    # 4. Recupero e Salvataggio del Codice Generato
    final_code = final_state.get("final_combined_code")

    if not final_code:
        print("‚ùå Error: No code was generated by the graph.")
        return None

    # Salviamo lo script generato su disco (utile per debug o riuso)
    try:
        with open(script_output_path, "w", encoding="utf-8") as f:
            f.write(final_code)
        print(f"üêç Generated script saved to: {script_output_path}")
    except Exception as e:
        print(f"‚ö†Ô∏è Warning: Could not save python script: {e}")

    # 5. Esecuzione Locale del Codice (Sandbox)
    # Poich√© il grafo restituisce codice, dobbiamo eseguirlo per ottenere il DataFrame
    print("‚öôÔ∏è  Executing generated code to produce DataFrame...")

    execution_scope = {}
    try:
        # Esegue il codice stringa nel dizionario execution_scope
        exec(final_code, execution_scope)

        # Cerchiamo la funzione orchestratrice definita nel Merger
        # (Default name in graph_orchestrator.py: 'generate_full_dataset')
        if "generate_full_dataset" in execution_scope:
            generator_func = execution_scope["generate_full_dataset"]

            # Eseguiamo la funzione
            df = generator_func(num_rows)

            # Salvataggio CSV
            if df is not None:
                df.to_csv(output_path, index=False)
                print(f"‚úÖ GENERATION COMPLETED SUCCESSFULLY!")
                print(f"üíæ CSV saved to: {output_path}")
                return df
            else:
                print("‚ùå The generated function returned None instead of a DataFrame.")
                return None
        else:
            print("‚ùå Critical: 'generate_full_dataset' function not found in generated code.")
            return None

    except Exception as e:
        print(f"‚ùå Runtime Error during dataset generation: {e}")
        traceback.print_exc()
        return None